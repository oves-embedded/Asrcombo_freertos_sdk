/*
 * Copyright (c) 2022 ASR Microelectronics (Shanghai) Co., Ltd. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "asr_aes.h"
#include "asr_sec_hw_common.h"
#include "duet_pinmux.h"
#include "duet_uart.h"
#include "printf_uart.h"
#define INTEG_TEST_PRINT                        printf
#define UART_TX_PIN PAD2
#define UART_RX_PIN PAD3
#define UART_TEST_INDEX UART1_INDEX
#define UART_TEST UART1
#define UART_TEST_INDEX UART1_INDEX
#define UART_HW_FLOW_CONTROL_ENABLE 1
#define UART_HW_FLOW_CONTROL_DISABLE 0


void uart_recv_test(char data)
{
  //UART_SendData(data);
  UART_SendData(getUartxViaIdx(UART_TEST_INDEX), data);
}

void set_uart_config(uint8_t uart_idx, uint8_t hw_flow_control)
{
  duet_uart_dev_t uart_config_struct = {0};
  duet_uart_struct_init(&uart_config_struct);
  uart_config_struct.port = uart_idx;
  uart_config_struct.priv = uart_recv_test;
  // set user define config
  uart_config_struct.config.baud_rate = UART_BAUDRATE_115200;
  if (hw_flow_control)
    uart_config_struct.config.flow_control = FLOW_CTRL_CTS_RTS;
  else
    uart_config_struct.config.flow_control = FLOW_CTRL_DISABLED;
  duet_uart_init(&uart_config_struct);

}

void set_uart_pinmux(uint8_t uart_idx, uint8_t hw_flow_control)
{
  switch (uart_idx)
  {
    case UART0_INDEX:
      duet_pinmux_config(PAD0, PF_UART0);
      duet_pinmux_config(PAD1, PF_UART0);
      if (hw_flow_control)
      {
        duet_pinmux_config(PAD6, PF_UART0);
        duet_pinmux_config(PAD7, PF_UART0);
      }
      break;
    case UART1_INDEX:
      duet_pinmux_config(PAD2, PF_UART1);
      duet_pinmux_config(PAD3, PF_UART1);
      if (hw_flow_control)
      {
        duet_pinmux_config(PAD14, PF_UART1);
        duet_pinmux_config(PAD15, PF_UART1);
      }
      break;
    case UART2_INDEX:
      duet_pinmux_config(PAD12, PF_UART2);
      duet_pinmux_config(PAD13, PF_UART2);
      if (hw_flow_control)
      {
        duet_pinmux_config(PAD10, PF_UART2);
        duet_pinmux_config(PAD11, PF_UART2);
      }
      break;
    default:
      break;
  }
}

#define MAX_TEST_DATA_SIZE               256
#define MAX_AES_CCM_DATA_SIZE_VECTOR     0x40
#define AES_TESTS_NUMBER                 0x4
typedef enum OperationType_enum
{
    INTEGRATED_OPERATION, NON_INTEGRATED_OPERATION, OperationTypeLast = 0x7FFFFFFF,

} OperationType_t;
typedef enum BufferType_enum
{
    NON_INPLACE_BUFFER, INPLACE_BUFFER, BufferTypeLast = 0x7FFFFFFF,

} BufferType_t;

typedef struct aesDataStuct
{
    uint8_t                aesTest_name[MAX_TEST_DATA_SIZE];
    uint8_t                TST_KeyData[AES_KEY_MAX_SIZE_IN_BYTES];
    uint8_t                TST_KeySize;
    AesIv_t                aesTest_IvCounter;
    uint8_t                aesTest_input_data[MAX_TEST_DATA_SIZE];
    uint8_t                aesTest_output_data[MAX_TEST_DATA_SIZE];
    uint8_t                aesTest_Expected_output_data[MAX_TEST_DATA_SIZE];
    uint16_t               aesTest_DataSize;
    AesOperationMode_t     aesTest_OperationMode;
    AesEncryptMode_t       aesTest_EncDecMode;
    uint32_t               aesTest_OutputDataSize;
} duet_aesDataStuct;

duet_aesDataStuct aesVectors[] = {
    {
        /*symTest_name*/
        {"AES_CBC_mode/NonIntegrated/Inplace/AES_Encrypt/AES_Key128BitSize/16bytes"},
        /*Key*/
        { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        16 ,
        /*IV*/
        {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},
        /*Input data*/
        {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
        /*Output data*/
        {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
        /*Expected output*/
        {0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46,0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d},
        /*Data size*/
        16,
        /*AES mode */
        AES_MODE_CBC,
        /*Operation mode */
        AES_ENCRYPT,
        /*Output data size*/
        16
    },
    {    /*symTest_name*/
        {"AES_ECB_mode/NonIntegrated/Inplace/AES_Decrypt/AES_Key128BitSize/32bytes"},
        /*Key*/
        {0x43,0xb1,0xcd,0x7f,0x59,0x8e,0xce,0x23,0x88,0x1b,0x00,0xe3,0xed,0x03,0x06,0x88},
        16,
        /*IV*/
        {0},
        /*Input data*/
        {0xb9,0xaf,0xfe,0xe2,0x98,0xcd,0x0f,0x4a,0x67,0x08,0x44,0xa6,0xd6,0xce,0xef,0x87,
         0xcf,0x41,0x2b,0x67,0xb3,0xad,0x95,0x18,0x94,0x4c,0x52,0x1e,0x91,0xb8,0x24,0xfc},
        /*Output data*/
        {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
        /*Expected output*/
        {0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
         0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
        /*Data size*/
        32,
        /*AES mode */
        AES_MODE_ECB,
        /*Operation mode */
        AES_DECRYPT,
        /*Output data size*/
        32
    },
    {
        {"AES_CTR_mode/Integrated/AES_Decrypt/AES_Key128BitSize/212bytes"},
        /*Key*/
        {0x08,0x82,0x94,0x8f,0xf5,0xf0,0xea,0xf1,0xe9,0x08,0x0a,0x98,0x1e,0x27,0xac,0xee},
        16,
        /*IvCounter*/
        {0x25,0xc3,0x38,0xde,0x08,0xa8,0x20,0x9e,0xa0,0x97,0x71,0x95,0x42,0x60,0x47,0xbc},
        /*input_data*/
        {0x31,0xb5,0x74,0x50,0x2e,0x66,0x56,0xf7,0xb0,0x23,0x52,0xc2,0x9d,0xa2,0x7d,0xca,
         0xa6,0xcc,0xc8,0x7b,0xae,0xd1,0xa2,0x32,0x5e,0x92,0xa7,0xab,0xa4,0x11,0xce,0xbe,
         0x38,0x42,0x4e,0x53,0x7f,0xe0,0xda,0x17,0xba,0x19,0x4f,0xf1,0xe8,0x81,0xd4,0x05,
         0x1f,0x59,0xf1,0xe2,0x57,0x5d,0xf1,0x0f,0xab,0xb9,0xfd,0x7c,0x5c,0xff,0xf9,0xc7,
         0xf4,0xa4,0xff,0x40,0x6e,0x98,0xa6,0x5f,0x55,0x57,0x1f,0x92,0x8e,0xa4,0xf7,0xdf,
         0xf8,0x94,0xf2,0xc3,0x08,0xfb,0x7b,0xea,0x43,0x71,0x1e,0x64,0xd1,0xec,0xdc,0xa8,
         0x85,0x7c,0xd3,0x6c,0x8b,0x84,0x8d,0xe4,0x38,0x1e,0x12,0x20,0x8a,0x38,0x1f,0x19,
         0x41,0x14,0xfc,0x4d,0x24,0xe3,0x55,0x43,0xf5,0x15,0x35,0x54,0x9e,0xb4,0x69,0x72,
         0x94,0x76,0x73,0x52,0x13,0xfd,0xb2,0x64,0x2b,0x1d,0xd0,0x30,0xde,0xfa,0xe2,0x18,
         0xf8,0xfb,0x22,0xf9,0xe2,0xf9,0x4d,0x8b,0xd7,0x55,0xf4,0xd8,0xbd,0x4e,0x03,0xf3,
         0x34,0xc0,0x62,0x8d,0xe0,0x49,0xc0,0x07,0x34,0x47,0x73,0x6b,0xdf,0x8f,0x27,0x0f,
         0xa4,0xe2,0xa8,0xa3,0x90,0x2e,0xb4,0x20,0xc0,0x5f,0x47,0xd8,0x65,0x18,0x3c,0x6a,
         0x71,0x72,0xd7,0x41,0x34,0x65,0x5d,0x02,0x27,0x6b,0x73,0x68,0xd8,0x9e,0xfa,0x9c,
         0xe3,0xaf,0x97,0xc5},
        /*Output data*/
        {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00},
         /*Expected output*/
        {0x5a,0xb6,0x19,0xc3,0xbb,0x9e,0x82,0x62,0x8d,0x56,0x0d,0xe8,0xc3,0x98,0xd8,0x0a,
         0x11,0xd7,0xe1,0xe2,0xf4,0x2e,0x23,0x89,0xf2,0x96,0x02,0xe8,0x23,0x5b,0xe9,0xcb,
         0xf0,0xd1,0x32,0x37,0x1b,0x43,0x46,0xfe,0x00,0x2c,0x05,0x90,0x1a,0xa9,0x68,0x14,
         0xc8,0x2f,0x64,0xb8,0x51,0x79,0x12,0x45,0x26,0xc5,0x0e,0xf6,0x68,0x40,0x1d,0x8a,
         0xaa,0xbf,0x12,0x98,0xf8,0xaf,0xf2,0x23,0x18,0x4f,0x56,0x6e,0x0f,0x1d,0x11,0x11,
         0xe8,0x8d,0x13,0x4d,0xb0,0x01,0x8d,0x9d,0xc5,0xf6,0x56,0x8d,0x51,0x7b,0x8e,0xcf,
         0x11,0xe8,0x81,0x8c,0x5b,0xcc,0xcd,0xf8,0x5f,0x27,0xc8,0x29,0xad,0xda,0x1c,0x29,
         0xf7,0x5b,0xb4,0x4a,0x18,0xad,0xdc,0xb9,0x56,0x90,0xa3,0x56,0xe4,0xf5,0x84,0xc3,
         0xab,0xb4,0x46,0xbb,0x4b,0x81,0x21,0xa6,0x5c,0x1d,0x22,0x6a,0xf9,0xc9,0xd1,0x83,
         0x7f,0x00,0x10,0x56,0x92,0x65,0x46,0xc2,0x61,0xfb,0xbd,0xf9,0x2b,0x94,0x49,0x8e,
         0x03,0x8c,0x2b,0xcf,0xd0,0xb6,0x34,0x54,0x97,0x97,0x2e,0xd8,0xfd,0xd2,0x77,0x48,
         0x07,0xe4,0xef,0x1a,0x25,0x11,0x14,0xe0,0x6f,0x9e,0x6c,0x1d,0x2e,0x41,0x24,0x57,
         0x9e,0xd6,0xf6,0x6d,0xf2,0x53,0x50,0x2b,0x99,0xfe,0xb2,0x1c,0xc0,0xde,0x57,0x9f,
         0x18,0x6f,0x19,0x3d},
        /*Data size*/
        212,
        /*AES mode*/
        AES_MODE_CTR,
        /*Operation mode */
        AES_DECRYPT,
        /*Output data size*/
        212
    },
    {
        {"AES_CMAC_mode/Integrated/AES_Encrypt/AES_Key128BitSize/40bytes"},
        /*Key*/
        {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        16,
        /*IvCounter*/
        {0x00},
        /*input_data*/
        {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
         0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
         0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11 },
        /*output_data*/
        {0},
        /*Expected output*/
        { 0xdf,0xa6,0x67,0x47,0xde,0x9a,0xe6,0x30,0x30,0xca,0x32,0x61,0x14,0x97,0xc8,0x27},
        /*Data size*/
        40,
        /*AES mode*/
        AES_MODE_CMAC,
        /*Operation mode */
        AES_ENCRYPT,
        /*Output data size*/
        16
    }
};

static bool duet_should_set_iv(AesOperationMode_t operationMode)
{
    return (operationMode == AES_MODE_CBC) ||
         (operationMode == AES_MODE_CTR) ||
         (operationMode == AES_MODE_CBC_MAC);
}

int duet_aes_tests(void)
{
    int                  ret     = 0;
    uint32_t             test_index, block_index;
    BufferType_t         buffer_index;
    uint8_t              *dataInBuff;
    uint8_t              *dataOutBuff;
    AesUserContext_t ContextID;
    AesUserKeyData_t keyData;
    size_t               outSize = 0;
    /*Loop for aes test vectors*/
    for (buffer_index = NON_INPLACE_BUFFER; buffer_index <= INPLACE_BUFFER; buffer_index++)
        for (test_index = 0; test_index < AES_TESTS_NUMBER; test_index++)
        {
            /*In case of non Linux platform set data pointers to test's vectors */
            dataInBuff  = aesVectors[test_index].aesTest_input_data;
            dataOutBuff = aesVectors[test_index].aesTest_output_data;
            INTEG_TEST_PRINT(" Test Parameters : %s \r\n", aesVectors[test_index].aesTest_name);
            /*If current iteration is for inplace buffer type, set the output data pointer to input data pointer*
            * to check inplace operation                                    */
            if (buffer_index == INPLACE_BUFFER)
            {
                /*Perform inplace operation*/
                dataOutBuff = dataInBuff;
                INTEG_TEST_PRINT(" Inplace buffer operaion \r\n");
            }
            else
            {
                INTEG_TEST_PRINT(" Non-Inplace buffer operaion \r\n");
            }


            /*Call non-integrated APIs - first SaSi_AesInit*/
            ret = asr_AesInit(&ContextID, aesVectors[test_index].aesTest_EncDecMode,
                               aesVectors[test_index].aesTest_OperationMode, AES_PADDING_NONE);

            /*,
                aesVectors[test_index].aesTest_Key,               aesVectors[test_index].aesTest_KeySize,*/

            if (ret != ASR_SILIB_RET_OK)
            {
                INTEG_TEST_PRINT("CRYS_AES_Init failed with error 0x%x\r\n", ret);
                return ret;
            }
            if (duet_should_set_iv(aesVectors[test_index].aesTest_OperationMode))
            {
                ret = asr_AesSetIv(&ContextID, aesVectors[test_index].aesTest_IvCounter);
                if (ret != ASR_SILIB_RET_OK)
                {
                    INTEG_TEST_PRINT("asr_AesSetIv failed with error 0x%x\r\n", ret);
                    return ret;
                }
            }
            keyData.pKey    = aesVectors[test_index].TST_KeyData;
            keyData.keySize = aesVectors[test_index].TST_KeySize;
            ret = asr_AesSetKey(&ContextID, AES_USER_KEY, &keyData, sizeof(keyData));
            if (ret != ASR_SILIB_RET_OK)
            {
                INTEG_TEST_PRINT("asr_AesSetKey failed with error 0x%x\r\n", ret);
                return ret;
            }
            /*Call CRYS_AES_Block for each 16 byte block data of the input buffer*/
            for (block_index = 0; block_index < aesVectors[test_index].aesTest_DataSize / AES_BLOCK_SIZE_IN_BYTES -
                                                1; block_index++)
            {
                ret = asr_AesBlock(&ContextID, dataInBuff + (block_index * AES_BLOCK_SIZE_IN_BYTES),
                                    AES_BLOCK_SIZE_IN_BYTES,
                                    dataOutBuff + (block_index * AES_BLOCK_SIZE_IN_BYTES));

                if (ret != ASR_SILIB_RET_OK)
                {
                    INTEG_TEST_PRINT("asr_AesBlock failed with error 0x%x\r\n", ret);
                    return ret;
                }
            }
            outSize = aesVectors[test_index].aesTest_DataSize - (block_index * AES_BLOCK_SIZE_IN_BYTES);
            /*Call CRYS_AES_Finish for the last block (the size may be 0)*/
            if (aesVectors[test_index].aesTest_OperationMode == AES_MODE_XCBC_MAC ||
                aesVectors[test_index].aesTest_OperationMode == AES_MODE_CMAC)
            {
                /*For XCBC_MAC and CMAC modes we should pass to SaSi_AesFinish the begining of the output buffer*/
                ret = asr_AesFinish(&ContextID, outSize, dataInBuff + (block_index * AES_BLOCK_SIZE_IN_BYTES),
                                     outSize, dataOutBuff, &outSize);

            }
            else
            {
                /*For the rest of the modes we should pass to SaSi_AesFinish the relevant offset of output buffer*/
                ret = asr_AesFinish(&ContextID, outSize, dataInBuff + (block_index * AES_BLOCK_SIZE_IN_BYTES),
                                     outSize, dataOutBuff + (block_index * AES_BLOCK_SIZE_IN_BYTES), &outSize);
            }

            if (ret != ASR_SILIB_RET_OK)
            {
                INTEG_TEST_PRINT("asr_AesFinish failed with error 0x%x\r\n", ret);
                return ret;
            }


            /*Check the output buffer with expected data */
            ret = memcmp(dataOutBuff, aesVectors[test_index].aesTest_Expected_output_data,
                         aesVectors[test_index].aesTest_OutputDataSize);
            if (ret != 0)
            {
                INTEG_TEST_PRINT("output buffer of the test failed\r\n");
                return ret;
            }
            INTEG_TEST_PRINT(" Passed \r\n");
        }
    return ret;
}

int main(void)
{
    uint8_t uart_idx        = UART_TEST_INDEX;
    uint8_t hw_flow_control = UART_HW_FLOW_CONTROL_DISABLE;
    // set pin mux
    set_uart_pinmux(uart_idx, hw_flow_control);
    set_uart_config(uart_idx, hw_flow_control);
    //    duet_uart_start(getUartxViaIdx(uart_idx));
    printf_uart_register(uart_idx);
    asr_security_engine_init();
    duet_aes_tests();
    asr_security_engine_deinit();
    while(1);
}

